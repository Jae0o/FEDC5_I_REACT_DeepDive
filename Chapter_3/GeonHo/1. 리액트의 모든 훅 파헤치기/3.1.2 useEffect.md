# useEffect

정확한 정의 ?<br>
앱 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.<br>
또한 부수 효과가 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다.

부수 효과란 ?<br>
컴포넌트 내부에서 상태값을 변경하거나, 네트워크 요청을 보내거나, DOM을 조작하는 등의 작업을 말한다.

<br>

useEffect에서 디펜던시 어레이의 값이 변경될 때 콜백 함수가 실행됨은 알고있다.<br>
그런데 useEffect는 어떻게 그 값이 변경됨을 아는걸까?

useEffect는 js의 Proxy나 데이터 바인딩, 옵저버 같은 기능을 이용한 것이 아니고 <br>
렌더링 할 때마다 의존성에 있는 값을 보며, 이 값이 이전과 달라진게 있다면 부수 효과를 실행하는 평범한 함수이다. <br>
즉, state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

<br>

## 클린업 함수의 목적

클린업 함수라 불리는 useEffect 내부에서 반환되는 함수는 정확히 무엇일까?

우선 클린업 함수는 새로운 값을 기반으로 렌더링 뒤에 실행되지만 <br>
이 변경된 값을 읽는 것이 아니라, 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.

이는 이벤트를 추가하기 전 이전에 등록했던 이벤터 핸들러를 삭제해주는 역할을 해준다. <br>
즉 특정 이벤트 핸들러가 무한히 추가되는 것을 방지해준다.

<br>

## 의존성 배열

의존성 배열에 아무것도 넣지 않는다면 컴포넌트가 렌더링 될 때마다 실행된다.

그렇다면 위와 같은 상황에서는 useEffect를 굳이 사용할 필요가 없지 않을까? <br>
그렇지 않다. <br>

아래 코드는 명백한 차이점이 있다.

```jsx
// 1번
const Component1 = () => {
  console.log("렌더링");
};

// 2번
const Component2 = () => {
  useEffect(() => {
    console.log("렌더링");
  });
};
```

1. SSR 관점에서 useEffect는 CSR에서 실행되는 것을 보장해준다. <br>
   덕분에 useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.
2. useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트의 렌더링이 완료된 후에 실행된다. <br>
   반면, 1번은 컴포넌트가 렌더링 되는 중에 실행된다.<br>
   그리고 무거운 작업의 경우 렌더링이 지연되므로 성능에 악영향을 끼칠 수 있다.

<br>

## useEffect를 사용할 때 주의할 점

### eslint-disable-line, react-hooks/exhaustive-deps 주석은 사용을 자제하자.

이는 클래스형 컴포넌트의 생명주기 메서드인 componentDidMount에 기반한 접근법이므로 가급적이면 사용하지 말자.

### useEffect의 첫 번째 인수에 함수명을 부여하자.

```jsx
useEffect(() => {
  function myLog() {
    console.log("렌더링");
  }
}, []);
```

useEffect의 목적을 명확히 하고 그 책임을 최소한으로 좁힐 수 있다.

<br>

### 거대한 useEffect를 만들지 말자.

### 불필요한 외부 함수를 만들지 말자.
