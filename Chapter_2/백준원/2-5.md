# 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 API 중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

이 세 가지가 모두 최적화 기법에 사용된다는 것은 알지만 정확히 언제 사용하는지에 대해서는 명확하게 답변하기 어렵다.

## 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불 할 때는 항상 신중해야 하네다

값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다.

이 비용이 리렌더링 비용의 가격은 상황에 따라 다르다 그래서 메모이제이션은 신중하게 접근해야 하고 섣부른 최적화는 항상 경계해야 한다.

## 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자-

메모이제이션 방법 2가지

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법
- memo를 일단 그냥 다 적용하는 방법

첫 번째 경우 가장 이상적인 상황이지만 리액트 애플리케이션의 규모가 커지고, 컴포넌트의 복잡성이 증가하는 상황에서 유지하기 힘들다

잘못된 memo를 지불해야 하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다

메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 이전 결과물을 사용해야 한다.

리액트의 재조정 알고리즘으로 이전 결과물은 어떻게든 저장해두기 때문에 memo로 지불해야 하는 비용은 props에 대한 얕은 비교 뿐이다

memo를 하지 않았을 때 발생할 수 있는 문제

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

useMemo와 useCallback을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다.

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return { double, triple };
}
```

useMath 훅에서 인수로 넘겨주는 값이 변하지 않는 이상 같은 값을 가지고 있어야 하는데 렌더링을 강제로 일으켜 보면 console.log가 출력된다.

그 이유는 함수형 컴포넌트인 App이 호출되면서 useMath가 계속해서 호출되고, 객체 내부의 값 같지만 참조가 변경되지 때문

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return useMemo(() => ({ double, triple }), [double, triple]);
}
```

useMath의 반환값을 useMemo로 감싼다면 값이 변경되지 않는 한 같은 결과물을 가질 수 있고, 그 덕분에 사용하는 쪽에서도 참조의 투명성을 유지할 수 있게 된다.

메모이제이션을 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.
