# 2.4 렌더링은 어떻게 일어나는가?

렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다.

리액트도 렌더링 작업을 위한 자체적인 렌더링 프로세스가 있으며, 이를 이해하는 것은 곧 리액트를 이해하는 첫걸음.

## 2.4.1 리액트의 렌더링이란?

리액트에서의 렌더링이란, 리액트 앱 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 <br>
어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에게 제공할 것인지 계산하는 일련의 과정을 의미한다.

## 2.4.2 리액트의 렌더링이 일어나는 이유

렌더링 과정보다 더 중요한 것은 렌더링이 언제 발생하느냐이다.

렌더링 시나리오에 대하여 알아보자

1. 최초 렌더링<br>
   유저가 최초로 앱에 진입 하였을 때
2. 리렌더링<br>
   리렌더링이란, 최초 진입 후로 발생하는 모든 렌더링을 의미한다.
   리렌더링이 발생하는 경우에 대하여 알아보자

- 클래스형 컴포넌트의 setState가 실행되는 경우
  - state의 변화는 컴포넌트 상태의 변화를 의미한다.
- 클래스형 컴포넌트의 forceUpdate가 실행되는 경우
  - 클래스형 컴포넌트에서 렌더링을 수행하는 것은 render인데, 이 render가 state, props가 아닌 <br>
    다른 값에 의존하고 있어 리렌더링을 자동으로 실행할 수 없다면 forceUpdate를 사용하여 강제로 렌더링을 실행할 수 있다.
    다만, 이는 개발자가 강제 렌더링이 필요하다고 선언한 것으로 간주한다. <br>
    때문에 shouldComponentUpdate 메서드를 무시하고 건너뛴다. <br>
    또한, render 내부에서 forceUpdate는 무한 루프를 발생시킬 수 있으므로 주의해야한다.
- 함수형 컴포넌트의 useState()의 2번째 배열 요소인 setter가 실행되는 경우 <br>
- 함수형 컴포넌트의 useReducer()의 2번째 배열 요소인 dispatch가 실행되는 경우 <br>
- 컴포넌트의 key props가 변경되는 경우 <br>

<br>

리액트 배열에서 key 값을 사용하는 이유?

리액트에서 key는 리렌더링이 발생하는 동안, 형제 요소들 사이에서 동일한 요소를 식별해주는 값이다. <br>
리렌더링이 발생하면 current 트리와 workInProgress 트리 사이에서 어떤 컴포넌트가 변경이 있었는지 구분을 해야하는데, <br>
이 2개의 트리 사이에서 같은 컴포넌트인지 구별하기 위해 필요한 값이 바로 key이다. <br>

부모 컴포넌트가 리렌더링 된다면 자식 컴포넌트도 반드시 리렌더링 된다.

참고로 MobX나 Redux 같은 상태관리 라이브러리가 리액트의 리렌더링으로 이어지지는 않는다.

## 2.4.3 리액트의 렌더링 프로세스

렌더링 프로세스가 실행되면 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.

업데이트가 필요한 컴포넌트를 발견하면

- 클래스형 컴포넌트 : 내부 render 실행.
- 함수형 컴포넌트 : FunctionComponent() 그 자체를 호출한 뒤 그 결과물을 저장한다.

이렇게 계산하는 과정을 리액트 재조정 (Reconciliation)이라고 한다.

리액트의 렌더링은 렌더 단계와 커밋 단계라는 2단계로 분리되어 실행된다.

## 2.4.4 렌더와 커밋

먼저 렌더 단계에 대해 알아보자.

렌더 단계는 컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업을 말한다.<br>
즉 컴포넌트를 실행해, 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐, 변경이 필요한 컴포넌트를 체크하는 단계인 것이다.

커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. <br>
이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

여기서 중요한 것은, **리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.**

커밋 단계까지 갈 필요가 없다면, 커밋 단계는 생략될 수 있다. <br>
즉, 가시적인 변경이 일어나지 않아도 리액트의 렌더링은 일어날 수 있다.

무튼, 이 렌더 단계와 커밋 단계, 두 과정으로 이뤄진 리액트 렌더링은 항상 동기식으로 작동했다. <br>
비동기식으로 작동할 경우, 각 단계마다 다른 UI를 볼 수 있기 때문. <br>

그럼에도 비동기 렌더링 시나리오는 때때로 유용할 수 있다. <br>
의도된 우선순위로 컴포넌트를 렌더링해 최적화 할 수 있는 비동기 렌더링인 '동시성 렌더링' 상황에 따라 유용하며, 리액트 18에 도입되엇다.

<br><br>

컴포넌트를 렌더링하는 작업은 하위 모든 컴포넌트에 영향을 미친다. <br>
그리고 부모가 변경됐다면 props가 변경됐는지와는 상관 없이 무조건 자식 컴포넌트도 리렌더링 된다. <br>
이는 렌더 단계에서 컴포넌트 비교를 위해 실행을 시키기 때문이다.
