## ✅ 2.3 클래스형 컴포넌트와 함수형 컴포넌트

- 함수형 컴포넌트에 훅이 등장한 이후 함수형 컴포넌트에서 상태나 생명주기 메서드 비슷한 작업을 흉내낼 수 있게 되자 복잡한 클래스형 컴포넌트보다 함수형 컴포넌트를 더 많이 쓰기 시작했다.

<br />

### 2.3.1 클래스형 컴포넌트

- 클래스형 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends 해야 한다.
- 클래스형 컴포넌트의 생명주기 메서드
  - 마운트 : 컴포넌트가 생성되는 시점
  - 업데이트 : 이미 생성된 컴포넌트의 내용이 변경되는 시점
  - 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점
  - render()
    - 항상 순수해야하며, 부수효과가 없어야한다.
    - 같은 입력값(props, state)이 들어가면 항상 같은 결과물을 반환해야 한다.
      - 따라서, render() 내부에서 state를 직접 업데이트 하는 this.setState를 호출해서는 안된다.
  - componentDidMount()
    - 컴포넌트가 마운트되고 준비되는 즉시 실행된다.
    - this.setState를 호출했다면 state가 변경되고, 즉시 다시 한번 렌더링을 시도하는데 이것은 브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.
    - state를 다루는 것은 생성자에서 하는 것이 좋다.
      - 이 생명주기에서는 생성자에서 할 수 없는 것, API 호출 후 업데이트, DOM에 의존적인 작업(이벤트 리스너 추가) 등을 하기 위해서다.
  - componentDidUpdate()
    - 컴포넌트가 업데이트가 발생한 직후 바로 실행된다.
  - componentWillUnmount()
    - 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.
    - 이벤트를 지우거나, API 호출을 취소하거나 타이머를 지우는 등의 작업을 하는데 유용하다.
  - shouldComponentUpdate()
    - state, props의 변경으로 리액트 컴포넌트가 다시 렌더링되는 것을 막고싶을 때 사용한다.
- 클래스형 컴포넌트의 한계
  - 데이터의 흐름을 예측하기 힘들다. 즉 state의 흐름을 예측하기 힘들다.
  - 애플리케이션 내부 로직의 재사용이 어렵다.
  - 기능이 많아질수록 컴포넌트의 크기가 커진다.
  - 함수에 비해 어렵다.
  - 코드 크기를 줄이기 어렵다.

<br />

### 2.3.2 함수형 컴포넌트

- this 바인딩을 조심할 필요가 없고, state가 객체가 아닌 원시값으로도 관리가 가능한 등 더 간편해졌다.

<br />

### 2.3.3 함수형 컴포넌트 vs. 클래스형 컴포넌트

- 생명주기 메서드의 부재
  - useEffect 훅을 사용해서 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현할 수 있다.
  - useEffect는 컴포넌트의 state를 활용해 '동기'적으로 '부수 효과'를 만드는 메커니즘이다.
